This program was produced by the
CodeWizardAVR V2.03.9 Standard
Automatic Program Generator
© Copyright 1998-2008 Pavel Haiduc, HP InfoTech s.r.l.
http://www.hpinfotech.com

Project :
Version :
Date    : 10/16/2009
Author  : E.Ebrahimi
Company :
Comments:


Chip type               : ATmega32
Program type            : Application
AVR Core Clock frequency: 8.000000 MHz
Memory model            : Small
External RAM size       : 0
Data Stack size         : 512
*****************************************************/
/******************************************************************************
//  Note: This program is just valid for cpu freq= 8 MHz or 16 MHz.(?????!!!!)
//  It is necessary to send the phone number beween character "D" , "C"
//  output pin is the PORTD (OC1A).(DTMF output)
********************************************************************************/

#include <mega32.h>
#include <delay.h>
#include <string.h>

void dtmf_init (void);
void Send_DTMF (char * number);

//************************** SIN TABLE *************************************
// Samples table : one period sampled on 128 samples and
// quantized on 7 bit
//**************************************************************************
flash unsigned char auc_SinParam [128] = {
64,67,
70,73,
76,79,
82,85,
88,91,
94,96,
99,102,
104,106,
109,111,
113,115,
117,118,
120,121,
123,124,
125,126,
126,127,
127,127,
127,127,
127,127,
126,126,
125,124,
123,121,
120,118,
117,115,
113,111,
109,106,
104,102,
99,96,
94,91,
88,85,
82,79,
76,73,
70,67,
64,60,
57,54,
51,48,
45,42,
39,36,
33,31,
28,25,
23,21,
18,16,
14,12,
10,9,
7,6,
4,3,
2,1,
1,0,
0,0,
0,0,
0,0,
1,1,
2,3,
4,6,
7,9,
10,12,
14,16,
18,21,
23,25,
28,31,
33,36,
39,42,
45,48,
51,54,
57,60};

//***************************  x_SW  ***************************************
//Table of x_SW (excess 8): x_SW = ROUND(8*N_samples*f*510/Fck)
//**************************************************************************

//high frequency (coloun)
//1209hz  ---> x_SW = 79
//1336hz  ---> x_SW = 87
//1477hz  ---> x_SW = 96
//1633hz  ---> x_SW = 107

const unsigned char auc_frequencyH [4] = {
107,96,
87,79};

//low frequency (row)
//697hz  ---> x_SW = 46
//770hz  ---> x_SW = 50
//852hz  ---> x_SW = 56
//941hz  ---> x_SW = 61

const unsigned char auc_frequencyL [4] = {
61,56,
50,46};


//**************************  global variables  *****************************************
unsigned char x_SWa = 0x00;               // step width of high frequency
unsigned char x_SWb = 0x00;               // step width of low frequency
unsigned int  i_CurSinValA = 0;           // position freq. A in LUT (extended format)
unsigned int  i_CurSinValB = 0;           // position freq. B in LUT (extended format)
unsigned int  i_TmpSinValA;               // position freq. A in LUT (actual position)
unsigned int  i_TmpSinValB;               // position freq. B in LUT (actual position)
//***************************************************************************************

//****************************************************************************************
void stop_dtmf(void){
 x_SWb=0;
 x_SWb=0;
 TCCR1A &= 127;
 }
//***************************************************************************************

void start_dtmf(void){
 TCCR1A |= 128 ;
}

//****************************************************************************************

void dtmf_init (void)
{
    TIMSK  = 0x04;                     // Int T1 Overflow enabled
    TCCR1A=0x81;
    TCCR1B=0x01;
    DDRD=0x20;                    // PORTD (OC1A) as output
    stop_dtmf();
    #asm("sei";);                       // Interrupts enabled
}

//*****************************************************************************************


//**************************************************************************
// Timer overflow interrupt service routine
//**************************************************************************
interrupt [TIM1_OVF] void timer1_ovf_isr(void)
{
  // move Pointer about step width aheaed
  i_CurSinValA += x_SWa;
  i_CurSinValB += x_SWb;
  // normalize Temp-Pointer
  i_TmpSinValA  =  (char)(((i_CurSinValA+4) >> 3)&(0x007F));
  i_TmpSinValB  =  (char)(((i_CurSinValB+4) >> 3)&(0x007F));
  // calculate PWM value: high frequency value + 3/4 low frequency value
  OCR1A = (auc_SinParam[i_TmpSinValA] + (auc_SinParam[i_TmpSinValB]-(auc_SinParam[i_TmpSinValB]>>2)));
}

//***********************************************************************************************
void Send_DTMF (char * number)
{
  char ch=0,i=0;
  for(i=0;i<strlen(number);i++){
    ch=number[i];
        if(ch=='1'){
                x_SWb = auc_frequencyL[3];
                x_SWa = auc_frequencyH[3];
        }
        else if(ch=='2'){
                x_SWb = auc_frequencyL[3];
                x_SWa = auc_frequencyH[2];
        }
        else if(ch=='3'){
                x_SWb = auc_frequencyL[3];
                x_SWa = auc_frequencyH[1];
        }
        else if(ch=='4'){
                x_SWb = auc_frequencyL[2];
                x_SWa = auc_frequencyH[3];
        }
        else if(ch=='5'){
                x_SWb = auc_frequencyL[2];
                x_SWa = auc_frequencyH[2];
        }
        else if(ch=='6'){
                x_SWb = auc_frequencyL[2];
                x_SWa = auc_frequencyH[1];
        }
        else if(ch=='7'){
                x_SWb = auc_frequencyL[1];
                x_SWa = auc_frequencyH[3];
        }
        else if(ch=='8'){
                x_SWb = auc_frequencyL[1];
                x_SWa = auc_frequencyH[2];
        }
        else if(ch=='9'){
                x_SWb = auc_frequencyL[1];
                x_SWa = auc_frequencyH[1];
        }
        else if(ch=='0'){
                x_SWb = auc_frequencyL[0];
                x_SWa = auc_frequencyH[2];
        }
        else if(ch=='*'){
                x_SWb = auc_frequencyL[0];
                x_SWa = auc_frequencyH[3];
        }
        else if(ch=='#'){
                x_SWb = auc_frequencyL[0];
                x_SWa = auc_frequencyH[1];
        }
        else if(ch=='A'){
                x_SWb = auc_frequencyL[3];
                x_SWa = auc_frequencyH[0];
        }
        else if(ch=='B'){
                x_SWb = auc_frequencyL[2];
                x_SWa = auc_frequencyH[0];
        }
        else if(ch=='C'){
                x_SWb = auc_frequencyL[1];
                x_SWa = auc_frequencyH[0];
        }
        else if(ch=='D'){
                x_SWb = auc_frequencyL[0];
                x_SWa = auc_frequencyH[0];
        }

        start_dtmf();
        delay_ms(150);
        stop_dtmf();
        delay_ms(150);
    }; // end of for
 stop_dtmf();
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//****************************************************************************************************



//**************************************************************************************************



void main(void){


   char num[15];

   delay_ms(1000);
        dtmf_init();
        strcpyf(num,"D09127755555C";); // It is necessary to send the phone number beween character "D" , "C"
        Send_DTMF(num);
        while(1);
}


===================================================
#define BUFFER_SIZE 512 
	int chdev = 0, retv = 0, état = 0, n; 
	
	tampon de caractères [BUFFER_SIZE]; 
	const char * dtmf; 
	bool bVoice = false; 
	FICHIER * fp = 0; 
	
	VAD_PRM prm;
	
	VADClear (& prm); 
	prm.frame_len = BUFFER_SIZE; 
	prm.frame_step = BUFFER_SIZE; 
	
	fp = fopen (nom_fichier, "rb"); 
	
	int gramme = asrresource-> LoadGrammar ("dtmf.bnf", VERBIO_GRAMMAR_ABNF); 
	asrresource-> ActivateGrammar (gramme); 

	asrresource-> RecStrOpen (1500, 500, VERBIO_AUDIO_MULAW);
	asrresource-> VADOpen (& prm, VERBIO_AUDIO_MULAW);
	asrresource-> DTMFOpen (VERBIO_AUDIO_MULAW); 
	
	do { 
		n = fread (tampon, 1, BUFFER_SIZE, fp);

		
		dtmf = asrresource-> DTMFWrite (tampon, n); 
		if (dtmf) { 
			printf ("Tonalité DTMF% s reçue \ n", dtmf);
			
			if (asrresource-> CheckDTMFCompliance (dtmf)) { 
				printf ("Secuencia DTMF válida \ n"); 
				Pause; 
			} 
		}
		
		
		state = asrresource-> VADWrite (tampon, n); 
		if (! bVoice && state! = VVX_INIT && state! = VVX_SILENCE) 
			bVoice = true; 
				
		if (bVoice && n> 0) 
			n = asrresource-> RecStrWrite (tampon, n); 
	} 
	tandis que (n == BUFFER_SIZE); 

	fclose (fp);

	asrresource-> DTMFClose ();
	asrresource-> VADClose (); 
	asrresource-> RecStrClose (); 
	
	asrresource-> GetResult ();
	================================================
[ News ] [ Paper Feed ] [ Issues ] [ Authors ] [ Archives ] [ Contact ]


.. [Phrack Magazine] ..
.:: DTMF signalling and decoding ::.
Issues: [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] [ 10 ] [ 11 ] [ 12 ] [ 13 ] [ 14 ] [ 15 ] [ 16 ] [ 17 ] [ 18 ] [ 19 ] [ 20 ] [ 21 ] [ 22 ] [ 23 ] [ 24 ] [ 25 ] [ 26 ] [ 27 ] [ 28 ] [ 29 ] [ 30 ] [ 31 ] [ 32 ] [ 33 ] [ 34 ] [ 35 ] [ 36 ] [ 37 ] [ 38 ] [ 39 ] [ 40 ] [ 41 ] [ 42 ] [ 43 ] [ 44 ] [ 45 ] [ 46 ] [ 47 ] [ 48 ] [ 49 ] [ 50 ] [ 51 ] [ 52 ] [ 53 ] [ 54 ] [ 55 ] [ 56 ] [ 57 ] [ 58 ] [ 59 ] [ 60 ] [ 61 ] [ 62 ] [ 63 ] [ 64 ] [ 65 ] [ 66 ] [ 67 ] [ 68 ] [ 69 ]
Get tar.gzCurrent issue : #50 | Release date : 1997-04-09 | Editor : daemon9
Introduction	Phrack Staff
Phrack Loopback	Phrack Staff
Line Noise	various
Phrack Prophile on Aleph1	Phrack Staff
Linux TTY hijacking	halflife
Mastodonte	route
Insécurité SNMP	Alhambra
Cracking des mots de passe NT	Nihil
Plans de dérivation SS7	Cerveau
Recherche de personnes et messagerie vocale Skytel	pbxPhreak
Interfaçage câblé sous Linux	Professeur
Sécurité au niveau de l'application PC	Sideshow Bob
Signalisation et décodage DTMF	M. Blue
Système d'exploitation DCO	Monsieur Personne
Nouvelles de Phrack World	Alhambra
extrait.c	Personnel de Phrack
Titre : Signalisation et décodage DTMF
Auteur : Mr. Blue
                                .oO Phrack 50 Oo.

                            Volume sept, numéro cinquante

                                     13 sur 16
 
                         ================================
                         Encodage et décodage DTMF en C
                                    par Mr. Blue
                         ================================

  
introduction
------------
    Les tonalités DTMF sont les sons émis lorsque vous composez un numéro sur votre touche 
téléphone à tonalité. Les modems ont traditionnellement été le dispositif utilisé pour générer
ces tonalités d'un ordinateur. Mais les modems les plus sophistiqués du
marché d'aujourd'hui ne sont rien de plus qu'un DSP (processeur de signal numérique) avec
logiciel intégré d'accompagnement pour générer et interpréter des sons analogiques dans
données numériques. Les ordinateurs assis sur votre bureau ont plus de puissance CPU,
un OS plus complexe, et très souvent un DSP tout aussi sophistiqué. Il y a
aucune raison pour laquelle vous ne pouvez pas dupliquer la fonctionnalité d'un modem de droite
à l'intérieur du logiciel Unix, ce qui vous permet de mieux comprendre et
modifier le code.  

    Dans cet article, je fournis le code source pour encoder et décoder
Tonalités DTMF. Il existe de nombreuses utilisations de ce code, pour une utilisation sous unix
programmes de numérisation de téléphone et de numérotation de guerre, logiciel de messagerie vocale, automatisé
pbx brute force hacking, et d'innombrables autres légitimes et pas si
utilisations légitimes.

    Je n'entrerai pas en profondeur en expliquant les mathématiques sous-jacentes
théories derrière ce code. Si vous avez une formation en mathématiques suffisante, je
vous encourage à rechercher et à en apprendre davantage sur les algorithmes utilisés à partir de
votre bibliothèque universitaire locale; je n'ai pas l'intention de résumer ces
algorithmes, uniquement pour fournir du code Unix C qui peut être utilisé seul ou
élargi pour être utilisé dans le cadre dun programme plus large.  

    Utilisez l'utilitaire d'extraction inclus avec Phrack pour enregistrer l'individu
les fichiers source vers le répertoire dtmf /. Si vous trouvez ce code utile, je
vous encourage à montrer votre appréciation en partageant vos propres
connaissances avec Phrack.    

<++> dtmf / detect.h
/ * 
 *
 * aglorithme de goertzel, trouvez la puissance de différents
 * fréquences dans un DFT à N points.
 *
 * ftone / fsample = k / N   
 * k et N sont des nombres entiers. fsample est 8000 (8khz)
 * cela signifie la résolution de fréquence * maximale *
 * est fsample / N (chaque pas de k correspond à un
 * pas de fsample / N hz dans ftone)
 *
 * N a été choisi pour minimiser la somme des K erreurs pour
 * toutes les tonalités détectées ... voici les résultats:
 *
 * Le meilleur N est 240, avec la somme de toutes les erreurs = 3,030002
 * fréq freq réel k kactual kerr
 * ---- ------------ ------ ------- -----
 * 350 (366,66667) 10,500 (11) 0,500
 * 440 (433,33333) 13,200 (13) 0,200
 * 480 (466,66667) 14,400 (14) 0,400
 * 620 (633,33333) 18,600 (19) 0,400
 * 697 (700,00000) 20,910 (21) 0,090
 * 700 (700,00000) 21 000 (21) 0 000
 * 770 (766,66667) 23,100 (23) 0,100
 * 852 (866,66667) 25,560 (26) 0,440
 * 900 (900,00000) 27 000 (27) 0 000
 * 941 (933,33333) 28,230 (28) 0,230
 * 1100 (1100,00000) 33 000 (33) 0 000
 * 1209 (1200,00000) 36,270 (36) 0,270
 * 1300 (1300,00000) 39 000 (39) 0 000
 * 1336 (1333,33333) 40,080 (40) 0,080
 **** J'ai sorti 1477 .. trop près de 1500
 * 1477 (1466,66667) 44,310 (44) 0,310
 ****
 * 1500 (1500,00000) 45 000 (45) 0 000
 * 1633 (1633,33333) 48,990 (49) 0,010
 * 1700 (1700,00000) 51 000 (51) 0 000
 * 2400 (2400,00000) 72 000 (72) 0,000
 * 2600 (2600,00000) 78 000 (78) 0 000
 *
 * avis, 697 et 700hz sont indestructibles (même K)
 * toutes les autres tonalités ont une valeur k distincte.  
 * ces deux tons doivent être traités comme identiques pour notre
 * une analyse.
 *
 * Les pires tonalités à détecter sont 350 (erreur = 0,5, 
 * detet 367 hz) et 852 (erreur = 0,44, détecter 867 Hz). 
 * tous les autres sont très proches.
 *
 * /

#define FSAMPLE 8000
#define N 240

int k [] = {11, 13, 14, 19, 21, 23, 26, 27, 28, 33, 36, 39, 40,
 / * 44, * / 45, 49, 51, 72, 78,};

/ * coefficients pour les k ci-dessus comme:
 * 2 * cos (2 * pi * k / N)
 * /
float coef [] = {
1.917639, 1.885283, 1.867161, 1.757634, 
1.705280, 1.648252, 1.554292, 1.520812, 1.486290, 
1.298896, 1.175571, 1.044997, 1.000000, / * 0.813473, * / 
0,765367, 0,568031, 0,466891, -0,618034, -0,907981,};

#define X1 0 / * 350 tonalité * /
#define X2 1 / * 440 sonnerie, tonalité * /
#define X3 2 / * 480 sonnerie, occupé * /
#define X4 3 / * 620 occupé * /

#define R1 4 / * 697, ligne dtmf 1 * /
#define R2 5 / * 770, ligne dtmf 2 * /
#define R3 6 / * 852, ligne dtmf 3 * /
#define R4 8 / * 941, ligne dtmf 4 * /
#define C1 10 / * 1209, dtmf col 1 * /
#define C2 12 / * 1336, dtmf col 2 * /
#define C3 13 / * 1477, dtmf col 3 * /
#define C4 14 / * 1633, dtmf col 4 * /

#define B1 4 / * 700, boîte bleue 1 * /
#define B2 7 / * 900, bb 2 * /
#define B3 9 / * 1100, bb 3 * /
#define B4 11 / * 1300, bb4 * /
#define B5 13 / * 1500, bb5 * /
#define B6 15 / * 1700, bb6 * /
#define B7 16 / * 2400, bb7 * /
#define B8 17 / * 2600, bb8 * /

#define NUMTONES 18 

/ * valeurs renvoyées par detect 
 * 0-9 DTMF 0 à 9 ou MF 0-9
 * 10-11 DTMF *, #
 * 12-15 DTMF A, B, C, D
 * 16-20 MF dernière colonne: C11, C12, KP1, KP2, ST
 * 21 2400
 * 22 2600
 * 23 2400 + 2600
 * 24 DIALTONE
 * 25 ANNEAU
 * 26 OCCUPÉ
 * 27 silence
 * -1 invalide
 * /
#define D0 0
#define D1 1
#define D2 2
#define D3 3
#define D4 4
#define D5 5
#define D6 6
#define D7 7
#define D8 8
#define D9 9
#define DSTAR 10
#define DPND 11
#define DA 12
#define DB 13
#define DC 14
#define DD 15
#define DC11 16
#define DC12 17
#define DKP1 18
#define DKP2 19
#define DST 20
#define D24 21 
#define D26 22
#define D2426 23
#define DDT 24
#define DRING 25
#define DBUSY 26
#define DSIL 27

/ * traduction des codes ci-dessus en texte * /
char * dtran [] = {
  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
  "*", "#", "A B C D", 
  "+ C11", "+ C12", "KP1 +", "KP2 +", "+ ST",
  "2400", "2600", "2400 + 2600",
  "DIALTONE", "RING", "BUSY", ""};

#define RANGE 0,1 / * tout élément supérieur à RANGE * le pic est "activé" * /
#define THRESH 100.0 / * niveau minimum de la tonalité la plus forte * /
#define FLUSH_TIME 100 / * 100 images = 3 secondes * /

<-->
<++> dtmf / detect.c

/ *
 * detect.c
 * Ce programme détectera les tonalités MF et normales
 * tonalités dtmf ainsi que d'autres tonalités courantes telles que
 * comme BUSY, DIALTONE et RING.
 * Le programme utilise un algorithme de goertzel pour détecter
 * la puissance de différentes gammes de fréquences.
 *
 * l'entrée est supposée être des échantillons de 8 bits. Le programme
 * peut utiliser des échantillons signés ou non signés selon
 * à une option de compilation:
 *
 * cc -DUNSIGNED detect.c -o détecter
 *
 * pour les entrées non signées (soundblaster) et:
 *
 * cc detect.c -o détecter
 *
 * pour une entrée signée (échantillons amiga)
 * si vous ne voulez pas de rinçages, -DNOFLUSH
 * 
 * Tim N.
 * /

#include <stdio.h>
#include <math.h>
#include "detect.h"

/ *
 * calculer la puissance de chaque ton en fonction
 * à un algorithme de goertzel modifié décrit dans
 * _applications de traitement du signal numérique utilisant le
 * Famille ADSP-2100_ par Analog Devices
 *
 * l'entrée est 'data', N valeurs d'échantillon
 *
 * la sortie est 'power', NUMTONES valeurs
 * correspondant à la puissance de chaque tonalité 
 * /
calc_power (données, puissance)
#ifdef NON SIGNÉ
données char * non signées;
#autre
char * data;
#fin si
flotteur * puissance;
{
  float u0 [NUMTONES], u1 [NUMTONES], t, in;
  int i, j;
  
  pour (j = 0; j <NOMBRE; j ++) {
    u0 [j] = 0,0;
    u1 [j] = 0,0;
  }
  pour (i = 0; i <N; i ++) {/ * feedback * /
#ifdef NON SIGNÉ
    in = ((int) données [i] - 128) / 128,0;
#autre
    in = données [i] / 128,0;
#fin si
    pour (j = 0; j <NOMBRE; j ++) {
      t = u0 [j];
      u0 [j] = in + coef [j] * u0 [j] - u1 [j];
      u1 [j] = t;
    }
  }
  pour (j = 0; j <NOMBRE; j ++) / * anticipation * /
    puissance [j] = u0 [j] * u0 [j] + u1 [j] * u1 [j] - coef [j] * u0 [j] * u1 [j]; 
  retour (0);
}


/ *
 * détecter quels signaux sont présents.
 *
 * renvoyer les valeurs définies dans le fichier d'inclusion
 * Remarque: conflit DTMF 3 et MF 7. Résoudre
 * le programme ne signale que MF 7 entre
 * un KP et un ST, sinon DTMF 3 est retourné
 * /
décoder (données)
char * data;
{
  puissance flottante [NOMBRE], seuil, puissance max;
  int sur [NUMTONES], on_count;
  int bcount, rcount, ccount;
  ligne int, col, b1, b2, i;
  int r [4], c [4], b [8];
  statique int MFmode = 0;
  
  calc_power (données, puissance);
  pour (i = 0, maxpower = 0.0; i <NOMBRE; i ++)
    if (puissance [i]> puissance max)
      maxpower = puissance [i]; 
/ *
pour (i = 0; i <NOMBRE; i ++) 
  printf ("% f,", puissance [i]);
printf ("\ n");
* /

  si (maxpower <THRESH) / * silence? * /
    retour (DSIL);
  seuil = RANGE * maxpower; / * plage de puissances admissible * /
  pour (i = 0, on_count = 0; i <NOMBRE; i ++) {
    if (puissance [i]> seuil) { 
      sur [i] = 1;
      on_count ++;
    } autre
      sur [i] = 0;
  }

/ *
printf ("% 4d:", on_count);
pour (i = 0; i <NOMBRE; i ++)
  putchar ('0' + sur [i]);
printf ("\ n");
* /

  if (on_count == 1) {
    si (sur [B7]) 
      retour (D24);
    si (sur [B8])
      retour (D26);
    retour (-1);
  }
 
  if (on_count == 2) {
    if (sur [X1] && sur [X2])
      retour (DDT);
    if (sur [X2] && sur [X3])
      retour (DRING);
    if (sur [X3] && sur [X4])
      retour (DBUSY);
    
    b [0] = sur [B1]; b [1] = sur [B2]; b [2] = sur [B3]; b [3] = sur [B4];
    b [4] = sur [B5]; b [5] = sur [B6]; b [6] = sur [B7]; b [7] = sur [B8];
    c [0] = sur [C1]; c [1] = sur [C2]; c [2] = sur [C3]; c [3] = sur [C4];
    r [0] = sur [R1]; r [1] = sur [R2]; r [2] = sur [R3]; r [3] = sur [R4];

    pour (i = 0, bcount = 0; i <8; i ++) {
      si (b [i]) {
        bcount ++;
        b2 = b1;
        b1 = i;
      }
    }
    pour (i = 0, rcount = 0; i <4; i ++) {
      si (r [i]) {
        rcount ++;
        ligne = i;
      }
    }
    pour (i = 0, ccount = 0; i <4; i ++) {
      si (c [i]) {
        ccount ++;
        col = i;
      }
    }

    if (rcount == 1 && ccount == 1) {/ * DTMF * /
      si (col == 3) / * A, B, C, D * /
        return (DA + ligne);
      autre {
        si (ligne == 3 && col == 0) 
           retour (DSTAR);
        si (ligne == 3 && col == 2)
           retour (DPND);
        si (ligne == 3)
           retour (D0);
        if (row == 0 && col == 2) {/ * DTMF 3 est en conflit avec MF 7 * /
          si (! MFmode)
            retour (D3);
        } autre 
          retour (D1 + col + ligne * 3);
      }
    }

    if (bcount == 2) {/ * MF * /
      / * b1 a un nombre supérieur, b2 a un nombre inférieur * /
      commutateur (b1) {
        cas 7: retour ((b2 == 6)? D2426: -1); 
        cas 6: retour (-1);
        cas 5: si (b2 == 2 || b2 == 3) / * KP * /
                  MFmode = 1;
                si (b2 == 4) / * ST * /
                  MFmode = 0; 
                retour (DC11 + b2);
        / * MF 7 est en conflit avec DTMF 3, mais si nous l'avons fait
         * ici alors DTMF 3 a déjà été testé pour 
         * /
        cas 4: retour ((b2 == 3)? D0: D7 + b2);
        cas 3: retour (D4 + b2);
        cas 2: retour (D2 + b2);
        cas 1: retour (D1);
      }
    }
    retour (-1);
  }

  si (on_count == 0)
    retour (DSIL);
  retour (-1); 
}

read_frame (fd, buf)
int fd;
char * buf;
{
  int i, x;

  pour (i = 0; i <N;) {
    x = lire (fd, & buf [i], Ni);
    si (x <= 0) 
      retour (0);
    i + = x;
  } 
  retour (1);
}

/ *
 * lire dans les images, sortie le décodé
 * résultats
 * /
dtmf_to_ascii (fd1, fd2)
int fd1;
FICHIER * fd2;
{
  int x, dernier = DSIL;
  char frame [N + 5];
  int silence_time;

  while (read_frame (fd1, frame)) {
    x = décoder (trame); 
/ *
if (x == -1) putchar ('-');
if (x == DSIL) putchar ('');
if (x! = DSIL && x! = - 1) putchar ('a' + x);
fflush (sortie standard);
continuer;
* /

    si (x> = 0) {
      si (x == DSIL)
        silence_time + = (silence_time> = 0)? 1: 0;
      autre
        silence_time = 0;
      if (silence_time == FLUSH_TIME) {
        fputs ("\ n", fd2);
        silence_time = -1; / * arrêter de compter * /
      }

      if (x! = DSIL && x! = dernier &&
         (dernier == DSIL || dernier == D24 || dernier == D26 ||
          dernier == D2426 || dernier == DDT || dernier == DBUSY ||
          dernier == DRING)) { 
        fputs (dtran [x], fd2);
#ifndef NOFLUSH
        fflush (fd2);
#fin si
      }
      dernier = x;
    }
  }
  fputs ("\ n", fd2);
}

main (argc, argv) 
int argc;
char ** argv;
{
  FILE * sortie;
  entrée int;

  entrée = 0;
  sortie = stdout;
  commutateur (argc) {
    cas 1: rupture;
    cas 3: sortie = fopen (argv [2], "w");
             if (! sortie) {
               perror (argv [2]);
               retour (-1);
             }
             /* tomber dans */
    cas 2: entrée = ouvert (argv [1], 0);
             if (entrée <0) {
               perror (argv [1]);
               retour (-1);
             }
             Pause;
     défaut:
        fprintf (stderr, "utilisation:% s [entrée [sortie]] \ n", argv [0]);
        retour (-1);
  }
  dtmf_to_ascii (entrée, sortie);
  fputs ("Terminé. \ n", sortie);
  retour (0);
}

<-->
<++> dtmf / gen.c

/ * -------- local définit (si nous avions plus .. fichier séparé) ----- * /
#define FSAMPLE 8000 / * taux d'échantillonnage, 8 KHz * /

/ *
 * FLOAT_TO_SAMPLE convertit un float compris entre -1,0 et 1,0 
 * dans un format valide pour être écrit dans un fichier son
 * ou vers un appareil audio 
 * /
#ifdef SIGNÉ
# définir FLOAT_TO_SAMPLE (x) ((char) ((x) * 127.0))
#autre
# définir FLOAT_TO_SAMPLE (x) ((char) ((x + 1.0) * 127.0))
#fin si

#define SOUND_DEV "/ dev / dsp"
échantillon de caractères typedef;
/ * ------------------------------------------------ --------------- * /

#include <fcntl.h>

/ *
 * prendre le sinus de x, où x vaut 0 à 65535 (pour 0 à 360 degrés)
 * /
float mysine (dans)
court en;
{
  coef statique [] = {
     3,140625, 0,02026367, -5,325196, 0,5446778, 1,800293};
  float x, y, res;
  signe int, i;
 
  if (in <0) {/ * force positive * /
    signe = -1;
    in = -in;
  } autre
    signe = 1;
  if (in> = 0x4000) / * 90 degrés * /
    dans = 0x8000 - dans; / * 180 degrés - po * /
  x = dans * (1 / 32768,0); 
  y = x; / * y contient x ^ i) * /
  res = 0;
  pour (i = 0; i <5; i ++) {
    res + = y * coef [i];
    y * = x;
  }
  return (res * signe); 
}

/ *
 * jouer tone1 et tone2 (en Hz)
 * pour 'longueur' millisecondes
 * envoie des échantillons à sound_out
 * /
two_tones (sound_out, tone1, tone2, longueur)
int sound_out;
unsigned int tone1, tone2, length;
{
#define BLEN 128
  échantillon cout [BLEN];
  flotter;
  non signé int ad1, ad2;
  court c1, c2;
  int i, l, x;
   
  ad1 = (ton1 << 16) / FSAMPLE;
  ad2 = (ton2 << 16) / FSAMPLE;
  l = (longueur * FSAMPLE) / 1000;
  x = 0;
  pour (c1 = 0, c2 = 0, i = 0;
       i <l;
       i ++, c1 + = ad1, c2 + = ad2) {
    out = (mysine (c1) + mysine (c2)) * 0.5;
    cout [x ++] = FLOAT_TO_SAMPLE (sortie);
    si (x == BLEN) {
      write (sound_out, cout, x * sizeof (sample));
      x = 0;
    }
  }
  écrire (sound_out, cout, x);
}

/ *
 * silence sur 'sound_out'
 * pour une longueur en millisecondes
 * /
silence (sound_out, longueur)
int sound_out;
longueur int non signée;
{
  int l, i, x;
  échantillon statique c0 = FLOAT_TO_SAMPLE (0.0);
  échantillon cout [BLEN];

  x = 0;
  l = (longueur * FSAMPLE) / 1000;
  pour (i = 0; i <l; i ++) {
    cout [x ++] = c0;
    si (x == BLEN) {
      write (sound_out, cout, x * sizeof (sample));
      x = 0;
    }
  }
  écrire (sound_out, cout, x);
}

/ *
 * jouer une seule tonalité dtmf
 * pendant un certain temps,
 * l'entrée est 0-9 pour le chiffre, 10 pour * 11 pour #
 * /
dtmf (sound_fd, chiffre, longueur)
int sound_fd;
int chiffre, longueur;
{
  / * Fréquences pour 0-9, *, # * /
  static int row [] = {
    941, 697, 697, 697, 770, 770, 770, 852, 852, 852, 941, 941};
  static int col [] = {
    1336, 1209, 1336, 1477, 1209, 1336, 1477, 1209, 1336, 1447,
    1209, 1477};

  two_tones (sound_fd, ligne [chiffre], col [chiffre], longueur);
}

/ *
 * prendre une chaîne et la sortie comme dtmf
 * caractères valides, 0-9, *, #
 * tous les autres jouent comme un silence de 50 ms 
 * /
composer (sound_fd, numéro)
int sound_fd;
char * nombre;
{
  int i, x;
  char c;

  pour (i = 0; nombre [i]; i ++) {
     c = nombre [i];
     x = -1;
     si (c> = '0' && c <= '9')
       x = c - «0»;
     sinon si (c == '*')
       x = 10;
     sinon si (c == '#')
       x = 11;
     si (x> = 0)
       dtmf (sound_fd, x, 50);
     silence (sound_fd, 50);
  }
}

principale()
{
  int sfd;
  nombre de caractères [100];

  sfd = ouvert (SOUND_DEV, O_RDWR);
  si (sfd <0) {
    perror (SOUND_DEV);
    retour (-1);
  }
  printf ("Entrez le numéro de téléphone:");
  obtient (nombre);
  composer (sfd, numéro);
}
<-->
<++> dtmf / Makefile
#
# Définit:
# UNSIGNED - utilise des échantillons 8 bits non signés
# sinon utiliser des échantillons 8 bits signés
#

CFLAGS = -DUNSIGNED

par défaut: détecter gen

détecter: detect.c
	$ (CC) detect.c -o détecter

gen: gen.c
	$ (CC) gen.c -o gen

clobber: nettoyer
	rm -rf détecter gen 

nettoyer:
	rm -rf * .o noyau a.out
<-->

EOF
[ News ] [ Paper Feed ] [ Issues ] [ Auteurs ] [ Archives ] [ Contact ]
© Copyleft 1985-2016, Phrack Magazine.





===================================================
[ News ] [ Paper Feed ] [ Issues ] [ Authors ] [ Archives ] [ Contact ]


..[ Phrack Magazine ]..
.:: DTMF signalling and decoding ::.
Issues: [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] [ 8 ] [ 9 ] [ 10 ] [ 11 ] [ 12 ] [ 13 ] [ 14 ] [ 15 ] [ 16 ] [ 17 ] [ 18 ] [ 19 ] [ 20 ] [ 21 ] [ 22 ] [ 23 ] [ 24 ] [ 25 ] [ 26 ] [ 27 ] [ 28 ] [ 29 ] [ 30 ] [ 31 ] [ 32 ] [ 33 ] [ 34 ] [ 35 ] [ 36 ] [ 37 ] [ 38 ] [ 39 ] [ 40 ] [ 41 ] [ 42 ] [ 43 ] [ 44 ] [ 45 ] [ 46 ] [ 47 ] [ 48 ] [ 49 ] [ 50 ] [ 51 ] [ 52 ] [ 53 ] [ 54 ] [ 55 ] [ 56 ] [ 57 ] [ 58 ] [ 59 ] [ 60 ] [ 61 ] [ 62 ] [ 63 ] [ 64 ] [ 65 ] [ 66 ] [ 67 ] [ 68 ] [ 69 ]
Get tar.gzCurrent issue : #50 | Release date : 1997-04-09 | Editor : daemon9
Introduction	Phrack Staff
Phrack Loopback	Phrack Staff
Line Noise	various
Phrack Prophile on Aleph1	Phrack Staff
Linux TTY hijacking	halflife
Juggernaut	route
SNMP insecurities	Alhambra
Cracking NT Passwords	Nihil
SS7 Diverter plans	Mastermind
Skytel Paging and Voicemail	pbxPhreak
Hardwire Interfacing under Linux	Professor
PC Application Level Security	Sideshow Bob
DTMF signalling and decoding	Mr. Blue
DCO Operating System	mrnobody
Phrack World News	Alhambra
extract.c	Phrack Staff
Title : DTMF signalling and decoding
Author : Mr. Blue
                                .oO Phrack 50 Oo.

                            Volume Seven, Issue Fifty

                                     13 of 16
 
                         ===============================
                         DTMF Encoding and Decoding In C
                                    by Mr. Blue
                         ===============================

  
Introduction
------------
    DTMF tones are the sounds emitted when you dial a number on your touch 
tone phone.  Modems have traditionally been the device used to generate
these tones from a computer.  But the more sophisticated modems on the
market today are nothing more than a DSP (digital signal processor) with
accompanying built-in software to generate and interpet analog sounds into
digital data.  The computers sitting on your desk have more cpu power,
a more complex OS, and very often a just as sophisticated DSP.  There is
no reason you can not duplicate the functionality of a modem from right
inside of unix software, providing you with a lot easier to understand and
modify code.  

    In this article I provide the source code to both encode and decode
DTMF tones.  There are numerous uses for this code, for use in unix based 
phone scanning and war dialing programs, voice mail software, automated
pbx brute force hacking, and countless other legitimate and not so
legitimate uses.

    I will not go into depth explaining the underlying mathematical
theories behind this code.  If you are of a sufficient math background I
would encourage you to research and learn about the algorithms used from
your local college library; it is not my intent to summarize these
algorithms, only to provide unix C code that can be used on its own or
expanded to be used as part of a larger program.  

    Use the extract utility included with Phrack to save the individual
source files out to the dtmf/ directory.  If you find this code useful, I
would encourage you to show your appreciation by sharing some of your own
knowledge with Phrack.    

<++> dtmf/detect.h
/* 
 *
 * goertzel aglorithm, find the power of different
 * frequencies in an N point DFT.
 *
 * ftone/fsample = k/N   
 * k and N are integers.  fsample is 8000 (8khz)
 * this means the *maximum* frequency resolution
 * is fsample/N (each step in k corresponds to a
 * step of fsample/N hz in ftone)
 *
 * N was chosen to minimize the sum of the K errors for
 * all the tones detected...  here are the results :
 *
 * Best N is 240, with the sum of all errors = 3.030002
 * freq  freq actual   k     kactual  kerr
 * ---- ------------  ------ ------- -----
 *  350 (366.66667)   10.500 (11)    0.500
 *  440 (433.33333)   13.200 (13)    0.200
 *  480 (466.66667)   14.400 (14)    0.400
 *  620 (633.33333)   18.600 (19)    0.400
 *  697 (700.00000)   20.910 (21)    0.090
 *  700 (700.00000)   21.000 (21)    0.000
 *  770 (766.66667)   23.100 (23)    0.100
 *  852 (866.66667)   25.560 (26)    0.440
 *  900 (900.00000)   27.000 (27)    0.000
 *  941 (933.33333)   28.230 (28)    0.230
 * 1100 (1100.00000)  33.000 (33)    0.000
 * 1209 (1200.00000)  36.270 (36)    0.270
 * 1300 (1300.00000)  39.000 (39)    0.000
 * 1336 (1333.33333)  40.080 (40)    0.080
 **** I took out 1477.. too close to 1500
 * 1477 (1466.66667)  44.310 (44)    0.310
 ****
 * 1500 (1500.00000)  45.000 (45)    0.000
 * 1633 (1633.33333)  48.990 (49)    0.010
 * 1700 (1700.00000)  51.000 (51)    0.000
 * 2400 (2400.00000)  72.000 (72)    0.000
 * 2600 (2600.00000)  78.000 (78)    0.000
 *
 * notice, 697 and 700hz are indestinguishable (same K)
 * all other tones have a seperate k value.  
 * these two tones must be treated as identical for our
 * analysis.
 *
 * The worst tones to detect are 350 (error = 0.5, 
 * detet 367 hz) and 852 (error = 0.44, detect 867hz). 
 * all others are very close.
 *
 */

#define FSAMPLE  8000
#define N        240

int k[] = { 11, 13, 14, 19, 21, 23, 26, 27, 28, 33, 36, 39, 40,
 /*44,*/ 45, 49, 51, 72, 78, };

/* coefficients for above k's as:
 *   2 * cos( 2*pi* k/N )
 */
float coef[] = {
1.917639, 1.885283, 1.867161, 1.757634, 
1.705280, 1.648252, 1.554292, 1.520812, 1.486290, 
1.298896, 1.175571, 1.044997, 1.000000, /* 0.813473,*/ 
0.765367, 0.568031, 0.466891, -0.618034, -0.907981,  };

#define X1    0    /* 350 dialtone */
#define X2    1    /* 440 ring, dialtone */
#define X3    2    /* 480 ring, busy */
#define X4    3    /* 620 busy */

#define R1    4    /* 697, dtmf row 1 */
#define R2    5    /* 770, dtmf row 2 */
#define R3    6    /* 852, dtmf row 3 */
#define R4    8    /* 941, dtmf row 4 */
#define C1   10    /* 1209, dtmf col 1 */
#define C2   12    /* 1336, dtmf col 2 */
#define C3   13    /* 1477, dtmf col 3 */
#define C4   14    /* 1633, dtmf col 4 */

#define B1    4    /* 700, blue box 1 */
#define B2    7    /* 900, bb 2 */
#define B3    9    /* 1100, bb 3 */
#define B4   11    /* 1300, bb4 */
#define B5   13    /* 1500, bb5 */
#define B6   15    /* 1700, bb6 */
#define B7   16    /* 2400, bb7 */
#define B8   17    /* 2600, bb8 */

#define NUMTONES 18 

/* values returned by detect 
 *  0-9     DTMF 0 through 9 or MF 0-9
 *  10-11   DTMF *, #
 *  12-15   DTMF A,B,C,D
 *  16-20   MF last column: C11, C12, KP1, KP2, ST
 *  21      2400
 *  22      2600
 *  23      2400 + 2600
 *  24      DIALTONE
 *  25      RING
 *  26      BUSY
 *  27      silence
 *  -1      invalid
 */
#define D0    0
#define D1    1
#define D2    2
#define D3    3
#define D4    4
#define D5    5
#define D6    6
#define D7    7
#define D8    8
#define D9    9
#define DSTAR 10
#define DPND  11
#define DA    12
#define DB    13
#define DC    14
#define DD    15
#define DC11  16
#define DC12  17
#define DKP1  18
#define DKP2  19
#define DST   20
#define D24   21 
#define D26   22
#define D2426 23
#define DDT   24
#define DRING 25
#define DBUSY 26
#define DSIL  27

/* translation of above codes into text */
char *dtran[] = {
  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
  "*", "#", "A", "B", "C", "D", 
  "+C11 ", "+C12 ", " KP1+", " KP2+", "+ST ",
  " 2400 ", " 2600 ", " 2400+2600 ",
  " DIALTONE ", " RING ", " BUSY ","" };

#define RANGE  0.1           /* any thing higher than RANGE*peak is "on" */
#define THRESH 100.0         /* minimum level for the loudest tone */
#define FLUSH_TIME 100       /* 100 frames = 3 seconds */

<-->
<++> dtmf/detect.c

/*
 * detect.c
 * This program will detect MF tones and normal
 * dtmf tones as well as some other common tones such
 * as BUSY, DIALTONE and RING.
 * The program uses a goertzel algorithm to detect
 * the power of various frequency ranges.
 *
 * input is assumed to be 8 bit samples.  The program
 * can use either signed or unsigned samples according
 * to a compile time option:
 *
 *    cc  -DUNSIGNED detect.c -o detect
 *
 * for unsigned input (soundblaster) and:
 *
 *    cc  detect.c -o detect
 *
 * for signed input (amiga samples)
 * if you dont want flushes,  -DNOFLUSH
 * 
 *                            Tim N.
 */

#include <stdio.h>
#include <math.h>
#include "detect.h"

/*
 * calculate the power of each tone according
 * to a modified goertzel algorithm described in
 *  _digital signal processing applications using the
 *  ADSP-2100 family_ by Analog Devices
 *
 * input is 'data',  N sample values
 *
 * ouput is 'power', NUMTONES values
 *  corresponding to the power of each tone 
 */
calc_power(data,power)
#ifdef UNSIGNED
unsigned char *data;
#else
char *data;
#endif
float *power;
{
  float u0[NUMTONES],u1[NUMTONES],t,in;
  int i,j;
  
  for(j=0; j<NUMTONES; j++) {
    u0[j] = 0.0;
    u1[j] = 0.0;
  }
  for(i=0; i<N; i++) {   /* feedback */
#ifdef UNSIGNED
    in = ((int)data[i] - 128) / 128.0;
#else
    in = data[i] / 128.0;
#endif
    for(j=0; j<NUMTONES; j++) {
      t = u0[j];
      u0[j] = in + coef[j] * u0[j] - u1[j];
      u1[j] = t;
    }
  }
  for(j=0; j<NUMTONES; j++)   /* feedforward */
    power[j] = u0[j] * u0[j] + u1[j] * u1[j] - coef[j] * u0[j] * u1[j]; 
  return(0);
}


/*
 * detect which signals are present.
 *
 * return values defined in the include file
 * note: DTMF 3 and MF 7 conflict.  To resolve
 * this the program only reports MF 7 between
 * a KP and an ST, otherwise DTMF 3 is returned
 */
decode(data)
char *data;
{
  float power[NUMTONES],thresh,maxpower;
  int on[NUMTONES],on_count;
  int bcount, rcount, ccount;
  int row, col, b1, b2, i;
  int r[4],c[4],b[8];
  static int MFmode=0;
  
  calc_power(data,power);
  for(i=0, maxpower=0.0; i<NUMTONES;i++)
    if(power[i] > maxpower)
      maxpower = power[i]; 
/*
for(i=0;i<NUMTONES;i++) 
  printf("%f, ",power[i]);
printf("\n");
*/

  if(maxpower < THRESH)  /* silence? */ 
    return(DSIL);
  thresh = RANGE * maxpower;    /* allowable range of powers */
  for(i=0, on_count=0; i<NUMTONES; i++) {
    if(power[i] > thresh) { 
      on[i] = 1;
      on_count ++;
    } else
      on[i] = 0;
  }

/*
printf("%4d: ",on_count);
for(i=0;i<NUMTONES;i++)
  putchar('0' + on[i]);
printf("\n");
*/

  if(on_count == 1) {
    if(on[B7]) 
      return(D24);
    if(on[B8])
      return(D26);
    return(-1);
  }
 
  if(on_count == 2) {
    if(on[X1] && on[X2])
      return(DDT);
    if(on[X2] && on[X3])
      return(DRING);
    if(on[X3] && on[X4])
      return(DBUSY);
    
    b[0]= on[B1]; b[1]= on[B2]; b[2]= on[B3]; b[3]= on[B4];
    b[4]= on[B5]; b[5]= on[B6]; b[6]= on[B7]; b[7]= on[B8];
    c[0]= on[C1]; c[1]= on[C2]; c[2]= on[C3]; c[3]= on[C4];
    r[0]= on[R1]; r[1]= on[R2]; r[2]= on[R3]; r[3]= on[R4];

    for(i=0, bcount=0; i<8; i++) {
      if(b[i]) {
        bcount++;
        b2 = b1;
        b1 = i;
      }
    }
    for(i=0, rcount=0; i<4; i++) {
      if(r[i]) {
        rcount++;
        row = i;
      }
    }
    for(i=0, ccount=0; i<4; i++) {
      if(c[i]) {
        ccount++;
        col = i;
      }
    }

    if(rcount==1 && ccount==1) {   /* DTMF */
      if(col == 3)  /* A,B,C,D */
        return(DA + row);
      else {
        if(row == 3 && col == 0 ) 
           return(DSTAR);
        if(row == 3 && col == 2 )
           return(DPND);
        if(row == 3)
           return(D0);
        if(row == 0 && col == 2) {   /* DTMF 3 conflicts with MF 7 */
          if(!MFmode)
            return(D3);
        } else 
          return(D1 + col + row*3);
      }
    }

    if(bcount == 2) {       /* MF */
      /* b1 has upper number, b2 has lower */
      switch(b1) {
        case 7: return( (b2==6)? D2426: -1); 
        case 6: return(-1);
        case 5: if(b2==2 || b2==3)  /* KP */
                  MFmode=1;
                if(b2==4)  /* ST */
                  MFmode=0; 
                return(DC11 + b2);
        /* MF 7 conflicts with DTMF 3, but if we made it
         * here then DTMF 3 was already tested for 
         */
        case 4: return( (b2==3)? D0: D7 + b2);
        case 3: return(D4 + b2);
        case 2: return(D2 + b2);
        case 1: return(D1);
      }
    }
    return(-1);
  }

  if(on_count == 0)
    return(DSIL);
  return(-1); 
}

read_frame(fd,buf)
int fd;
char *buf;
{
  int i,x;

  for(i=0; i<N; ) {
    x = read(fd, &buf[i], N-i);
    if(x <= 0) 
      return(0);
    i += x;
  } 
  return(1);
}

/*
 * read in frames, output the decoded
 * results
 */
dtmf_to_ascii(fd1, fd2)
int fd1;
FILE *fd2;
{
  int x,last= DSIL;
  char frame[N+5];
  int silence_time;

  while(read_frame(fd1, frame)) {
    x = decode(frame); 
/*
if(x== -1) putchar('-');
if(x==DSIL) putchar(' ');
if(x!=DSIL && x!=-1) putchar('a' + x);
fflush(stdout);
continue;
*/

    if(x >= 0) {
      if(x == DSIL)
        silence_time += (silence_time>=0)?1:0 ;
      else
        silence_time= 0;
      if(silence_time == FLUSH_TIME) {
        fputs("\n",fd2);
        silence_time= -1;   /* stop counting */
      }

      if(x != DSIL && x != last &&
         (last == DSIL || last==D24 || last == D26 ||
          last == D2426 || last == DDT || last == DBUSY ||
          last == DRING) )  { 
        fputs(dtran[x], fd2);
#ifndef NOFLUSH
        fflush(fd2);
#endif
      }
      last = x;
    }
  }
  fputs("\n",fd2);
}

main(argc,argv) 
int argc;
char **argv;
{
  FILE *output;
  int input;

  input = 0;
  output = stdout;
  switch(argc) {
    case 1:  break;
    case 3:  output = fopen(argv[2],"w");
             if(!output) {
               perror(argv[2]);
               return(-1);
             }
             /* fall through */
    case 2:  input = open(argv[1],0);
             if(input < 0) {
               perror(argv[1]);
               return(-1);
             }
             break;
     default:
        fprintf(stderr,"usage:  %s [input [output]]\n",argv[0]);
        return(-1);
  }
  dtmf_to_ascii(input,output);
  fputs("Done.\n",output);
  return(0);
}

<-->
<++> dtmf/gen.c

/* -------- local defines (if we had more.. seperate file) ----- */
#define FSAMPLE   8000   /* sampling rate, 8KHz */

/*
 * FLOAT_TO_SAMPLE converts a float in the range -1.0 to 1.0 
 * into a format valid to be written out in a sound file
 * or to a sound device 
 */
#ifdef SIGNED
#  define FLOAT_TO_SAMPLE(x)    ((char)((x) * 127.0))
#else
#  define FLOAT_TO_SAMPLE(x)    ((char)((x + 1.0) * 127.0))
#endif

#define SOUND_DEV  "/dev/dsp"
typedef char sample;
/* --------------------------------------------------------------- */

#include <fcntl.h>

/*
 * take the sine of x, where x is 0 to 65535 (for 0 to 360 degrees)
 */
float mysine(in)
short in;
{
  static coef[] = {
     3.140625, 0.02026367, -5.325196, 0.5446778, 1.800293 };
  float x,y,res;
  int sign,i;
 
  if(in < 0) {       /* force positive */
    sign = -1;
    in = -in;
  } else
    sign = 1;
  if(in >= 0x4000)      /* 90 degrees */
    in = 0x8000 - in;   /* 180 degrees - in */
  x = in * (1/32768.0); 
  y = x;               /* y holds x^i) */
  res = 0;
  for(i=0; i<5; i++) {
    res += y * coef[i];
    y *= x;
  }
  return(res * sign); 
}

/*
 * play tone1 and tone2 (in Hz)
 * for 'length' milliseconds
 * outputs samples to sound_out
 */
two_tones(sound_out,tone1,tone2,length)
int sound_out;
unsigned int tone1,tone2,length;
{
#define BLEN 128
  sample cout[BLEN];
  float out;
  unsigned int ad1,ad2;
  short c1,c2;
  int i,l,x;
   
  ad1 = (tone1 << 16) / FSAMPLE;
  ad2 = (tone2 << 16) / FSAMPLE;
  l = (length * FSAMPLE) / 1000;
  x = 0;
  for( c1=0, c2=0, i=0 ;
       i < l;
       i++, c1+= ad1, c2+= ad2 ) {
    out = (mysine(c1) + mysine(c2)) * 0.5;
    cout[x++] = FLOAT_TO_SAMPLE(out);
    if (x==BLEN) {
      write(sound_out, cout, x * sizeof(sample));
      x=0;
    }
  }
  write(sound_out, cout, x);
}

/*
 * silence on 'sound_out'
 * for length milliseconds
 */
silence(sound_out,length)
int sound_out;
unsigned int length;
{
  int l,i,x;
  static sample c0 = FLOAT_TO_SAMPLE(0.0);
  sample cout[BLEN];

  x = 0;
  l = (length * FSAMPLE) / 1000;
  for(i=0; i < l; i++) {
    cout[x++] = c0;
    if (x==BLEN) {
      write(sound_out, cout, x * sizeof(sample));
      x=0;
    }
  }
  write(sound_out, cout, x);
}

/*
 * play a single dtmf tone
 * for a length of time,
 * input is 0-9 for digit, 10 for * 11 for #
 */
dtmf(sound_fd, digit, length)
int sound_fd;
int digit, length;
{
  /* Freqs for 0-9, *, # */
  static int row[] = {
    941, 697, 697, 697, 770, 770, 770, 852, 852, 852, 941, 941 };
  static int col[] = {
    1336, 1209, 1336, 1477, 1209, 1336, 1477, 1209, 1336, 1447,
    1209, 1477 };

  two_tones(sound_fd, row[digit], col[digit], length);
}

/*
 * take a string and output as dtmf
 * valid characters, 0-9, *, #
 * all others play as 50ms silence 
 */
dial(sound_fd, number)
int sound_fd;
char *number;
{
  int i,x;
  char c;

  for(i=0;number[i];i++) {
     c = number[i];
     x = -1;
     if(c >= '0' && c <= '9')
       x = c - '0';
     else if(c == '*')
       x = 10;
     else if(c == '#')
       x = 11;
     if(x >= 0)
       dtmf(sound_fd, x, 50);
     silence(sound_fd,50);
  }
}

main()
{
  int sfd;
  char number[100];

  sfd = open(SOUND_DEV,O_RDWR);
  if(sfd<0) {
    perror(SOUND_DEV);
    return(-1);
  }
  printf("Enter fone number: ");
  gets(number);
  dial(sfd,number);
}
<-->
<++> dtmf/Makefile
#
# Defines:
#  UNSIGNED  -  use unsigned 8 bit samples
#               otherwise use signed 8 bit samples
#

CFLAGS= -DUNSIGNED

default:	detect gen

detect: detect.c
	$(CC) detect.c -o detect

gen:	gen.c
	$(CC) gen.c -o gen

clobber: clean
	rm -rf detect gen 

clean:
	rm -rf *.o core a.out
<-->

EOF
[ News ] [ Paper Feed ] [ Issues ] [ Authors ] [ Archives ] [ Contact ]
© Copyleft 1985-2016, Phrack Magazine.




================================================

 am very interest for your project as an experience Game developer and designer.
I have developed variant 2d & 3d games using Unity3D and Cocos2D-x.

Here are my experiences game app development.

https://play.google.com/store/apps/details?id=com.miniclip.eightballpool
https://itunes.apple.com/us/app/block-puzzle-wood/id1281878296?mt=8
https://play.google.com/store/apps/details?id=com.madfingergames.SamuraiIIAll&hl=en
https://play.google.com/store/apps/details?id=com.kiloo.subwaysurf&hl=en
https://youtu.be/kBSC01Eaixo

- Development the games for multi platform My programming platform is Unity3d, Cocos 2d-x and I can development the game using any programming language.
Unity3D and Cocos 2d-x provides the multi platform functions for mobile games as game development tools.
- Development online multi player game.
I can use Photon Server or App 42 server for multi player game.
These servers provide the strong multiple functions for games and I have mastered these servers.
If you use these server, you will get full project as your requirement.
- Create Art.
I am a game developer as well as designer, too. I have mastered Photoshop, 3D Max and Bleder3D.
So I can provide amazing 2d & 3d design such as characters, items, backgrounds, animations and UI.

As my experience and ability, I want to discuss for your project.
Please reply me.
King Regards!

Hello,
I have read your project details carefully
I am and have expertise in all platforms.
I have 05years experience in this field
I am waiting in chat window for your reply.
Inbox me I have some question & suggestions about the method of work.
thanks

Hello, I've read your description carefully and I am interested in your project.i am a professional game developer.
I have rich experience in these fields. I am working in these fields for 3 years, so I have enough confidence with these kinds of projects.
If you hire me, I will do my best so that I can satisfy you. I will be looking forward to hearing from you.

Best regards.
Junaid
========================================
ites-moi savoir si vous pouvez le faire.

Exigences du site Web: -
Accueil
À propos de nous
Nos partenaires commerciaux
Un service
Connexion (Franchisé)
Galerie
Tarification
En savoir plus (Accord / Brochure électronique / Format du tableau / Vidéos / Packages)
Appliquer maintenant 
Nos CSP
Nous contacter

Exigences de la page de connexion: -

Page de connexion pour le franchisé (nom d'utilisateur / mot de passe / mot de passe oublié / mobile enregistré et OTP)
Accueil
Profil (nom du franchisé / nom du propriétaire / photo / adresse / emplacement du franchisé / téléphone / portable / e-mail / Aadhar / Pancard / détails du compte / option de téléchargement de chèque annulé)
Reçu (le franchisé peut donner un reçu en espèces à son client contre son service et ajouter plus de service et une option d'ajout de taux requise)
Rapports (après avoir donné le reçu au client, ce sont les rapports affichés ici)
Téléchargements (l'administrateur créera le format d'application PDF / JPG pour les téléchargements. Le franchisé peut voir ce format et prendre une impression pour son client)
Certificat (L'administrateur entrera tous les détails du franchisé sur le backend et il s'affichera ici comme un certificat)
Contactez-nous (détails du panneau d'administration à afficher ici pour l'assistance aux franchisés)
Liens rapides (l'administrateur entrera le nom du service et l'URL du site Web sur le backend, il s'affichera ici comme Liens rapides
Liens de recherche (il est très facile d'identifier les liens)

Exigences administratives

L'administrateur peut contrôler la connexion du franchisé (profil / reçu / rapports / téléchargements / certificat / liens rapides)
L'administrateur peut contrôler le site Web (ajout de fonctionnalités / photos / détails / packages, etc.)  
Questions et rép